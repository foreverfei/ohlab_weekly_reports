## 二叉搜索树-删除节点
③删除有两个子节点的节点

当删除的节点存在两个子节点，那么删除之后，两个子节点的位置我们就没办法处理了，既然处理不了，我们就想到一种办法，用另一个节点来代替被删除的节点，那么用哪一个节点来代替呢？
![img_39.png](img_39.png)
我们直到二叉搜索树中的节点是按照关键字来进行排列的，某个节点的关键字次高节点是它的中序遍历后继节点。
用后继节点来代替删除的节点，显然该二叉树还是有序的
![img_40.png](img_40.png)'

     那么如何找到删除节点的中序后继节点呢？
    其实我们稍微分析，这实际上就是要找比删除节点关键值大的节点集合中最小的节点，只有这样代替删除节点后才能满足二叉搜索树的特性
④删除有必要吗？

通过上面的删除分类讨论，我们发现删除其实是挺复杂的，那么其实我们可以不用真正的删除该节点，只需要在Node类中增加一个标识字段isDelete，当该字段为true，标识该节点已经删除，反之则没有删除，这样删除节点就不会改变树的结构了。

影响就是查询时需要判断一下节点是否删除

---
**普通二叉搜索树的致命缺陷**
![img_41.png](img_41.png)

    可以看到这颗二叉搜索树的左子树实际上已经成为了链表

**怎么解决二叉搜索树退化成线性链表的问题？
如果插入元素时，树可以自动调整两边平衡，会保持不错的查找性能**

### AVL树简介
AVL树有什么特点？

具有二叉搜索树的全部特性
每个节点的左子树和右子树的高度差至多等于1

**为什么有了二叉平衡树还需要红黑树**
虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在O(logn)，不过却不是最佳的

因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入/删除节点的时候几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次称为一颗符合要求的平衡树

    显然，如果在那种插入删除很频繁的场景中，平衡树需要频繁的进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，便有了红黑树



### **红黑树原理**

**红黑树的性质**
![img_42.png](img_42.png)

前面讲到红黑树能自平衡，它靠的是什么？

**三种操作：左旋，右旋和变色**

## 1.变色
**结点的颜色由红变黑或由黑变红**

## 2.左旋（向左旋转）
**左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子树变为旋转结点的右子树，右子结点的右子树保持不变**
![img_43.png](img_43.png)
![img_46.png](img_46.png)

![img_44.png](img_44.png)

## 3.右旋（向右旋转）
**右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子树变为旋转结点的左子树，左子结点的左子树保持不变**

![img_47.png](img_47.png)

### 红黑树查找
**因为红黑树是一颗二叉平衡树，而且查找不会破坏树的平衡，所以查找跟二叉平衡树无异**

---
### 红黑树插入
**插入操作包括两部分工作**

**1. 查找插入的位置**

**2.插入后自平衡**


**注意：**

    插入结点，必须为红色，理由很简单，红色在父结点（如果存在）为黑色结点时，
    红黑树的黑色平衡没被破坏，不需要做自平衡操作，
    但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，
    破坏了红黑树的黑高性质，必须做自平衡。

在开始每个情景的讲解前，我们还是先来约定下
![img_48.png](img_48.png)


## 红黑树插入节点情景分析
**情景1：红黑树为空树**

最简单的一种情景，直接把插入结点作为根节点就行

注意，根据红黑树性质2,：根节点是黑色。还需要把插入结点设为黑色

**情景2：插入结点的Key已存在**

处理：更新当前节点的值，为插入结点的值
![img_49.png](img_49.png)

**情景3：插入结点的父结点为黑结点**

由于插入的结点是红色的，当插入结点的父结点为黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡
![img_50.png](img_50.png)

### **情景4：插入结点的父结点为红色**

    再次回想下红黑树的性质2：根节点是黑色
    ，如果插入结点的父结点为红结点，那么
    该父结点不可能为根节点，所以插入结点
    总是存在祖父结点，这一点很关键，因为后续的旋转操作肯定需要祖父结点的参与

**插入场景4.1：叔叔结点存在并且为红结点**

依据红黑树性质4可知。红色结点不能相连=>祖父结点肯定为黑结点

因为不可以同时存在两个相连的红结点，那么此时该插入子树的红黑树层数的情况是：黑红红，显然最简单的处理方式是把其改为红黑红处理：

1. 将P和U结点改为黑色
2. 将PP改为红色
3. 将PP设置为当前结点，继续后续处理
![img_51.png](img_51.png)


**可以看到，我们把PP节点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；
但如果PP的父结点是红色，则违反红黑树性质了，所以需要将PP设置为当前结点，继续做插入操作自平衡处理，直到平衡为止**

**插入场景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子节点**
注意：单纯从插入前来看，叔叔结点非红即空（NIL结点），否则的话破坏了红黑树性质5，此路径会比其他路径多一个黑色结点。
![img_52.png](img_52.png)

**插入场景4.2.1：新插入结点，为其父结点的左子结点（LL红色情况）**

**处理：**

1. 变颜色：将P设置为黑色，将PP设置为红色
2. 对PP节点进行右旋

![img_53.png](img_53.png)

**情景4.2.2：新插入结点，为其父结点的右子结点（LR红色情况）**
**处理：**

1. 对P进行左旋
 
**2. 将P设置为当前结点，得到LL红色情况**
3. 按照LL红色情况处理（1.变颜色2.右旋PP）

![img_54.png](img_54.png)

**情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点**

该情景对应情景4.2，只是方向反转，直接看图![img_55.png](img_55.png)

**插入场景4.3.1：新插入结点，为其父结点的右子结点（RR红色情况）**

![img_56.png](img_56.png)
处理：

1. 变颜色：将P设置为黑色，将PP设置为红色
2. 对PP结点进行左旋

**插入场景4.3.2：新插入结点，为其父结点的左子结点（RL红色情况）**
![img_57.png](img_57.png)

处理：
1. 对P进行右旋
2. 将P设置为当前结点，得到RR红色情况
3. 按照RR红色情况处理（1.变颜色2.左旋PP）

![img_58.png](img_58.png)


----






